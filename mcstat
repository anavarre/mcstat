#!/usr/bin/env php
<?php

/**
 * @file
 * mcstat reports memcache daemon statistics
 *
 * @requires PHP CLI 5.2 or newer.
 *
 * Copyright 2011 Jonathan W. Webb
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

define('DEFAULT_HOSTNAME', 'localhost');
define('DEFAULT_PORT', 11211);
define('DEFAULT_INTERVAL', 5);

declare(ticks=1);

exit(mcstat_main($argv, $argc));

function hr_metric($value) {
  if ($value > 1000000000) {
    $value = sprintf("%dG", ($value/1000000000));
  }
  else if ($value > 1000000) {
    $value = sprintf("%dM", ($value/1000000));
  }
  else if ($value > 1000) {
    $value = sprintf("%dk", ($value/1000));
  }
  return $value;
}

function hr_binary($value) {
  if ($value > 1073741824) {
    $value = sprintf("%dG", ($value/1073741824));
  }
  else if ($value > 1048576) {
    $value = sprintf("%dM", ($value/1048576));
  }
  else if ($value > 1024) {
    $value = sprintf("%dk", ($value/1024));
  }
  return $value;
}

function hr_time($seconds) {
  $time_interval = array(
    'd' => 86400,
    'h' => 3600,
    'm' => 60,
  );
  $output = '';
  foreach ($time_interval as $key => $value) {
    $$key = floor($seconds / $value);
    $seconds -= ($$key * $value);
    $output .= ($$key == 0) ? '' : $$key . "$key ";
  }
  return $output . $seconds . 's';
}

class mcstat_server
{
  protected $socket_ptr = null;
  protected $starting_data = null;
  protected $last_data = null;

  function __construct() {
    $this->last_data = array(
      'cmd_get' => 0,
      'get_hits' => 0,
      'get_misses' => 0,
      'bytes_read' => 0,
      'bytes_written' => 0,
    );
  }

  function connect($hostname, $port) {
    $this->socket_ptr = fsockopen($hostname, $port, $errno, $errstr, 30);
    if (!$this->socket_ptr) {
      return array('errno' => $errno, 'errstr' => $errstr);
    }
  }

  function disconnect() {
    if ($this->socket_ptr) {
      fwrite($this->socket_ptr, "quit\r\n");
      fclose($this->socket_ptr);
      print 'Connection closed' . PHP_EOL;
    }
  }

  function abort($signal) {
    if ($signal === SIGINT || $signal === SIGTERM) {
      print $this->output_stats_session();
      $this->disconnect();
      exit();
    }
  }

  function get_all_stats() {
    $data = array();
    fwrite($this->socket_ptr, "stats\r\n");
    while ($line = fgets($this->socket_ptr, 128)) {
      if (preg_match('/^END/', $line)) {
        break;
      }
      list($stat,$key,$value) = preg_split('/[\s]+/', $line, 3);
      $data[$key] = rtrim($value);
    }
    return $data;
  }

  function output_header() {
    return sprintf(
      "%8s  %4s  % 5s  % 5s  % 5s  % 5s  % 6s  % 6s  % 5s  % 5s" . PHP_EOL,
      'time',
      'cnct',
      'used',
      'gets',
      'hits',
      'miss',
      'hit%',
      'miss%',
      'in',
      'out'
    );
  }

  function output_stats_update() {
    $last = $this->last_data;
    $data = $start = $this->get_all_stats();

    $data['time_string'] = strftime("%T", $data['time']);
    $data['get_total'] = $data['cmd_get'] - $last['cmd_get'];
    $data['get_hits_total'] = $data['get_hits'] - $last['get_hits'];
    $data['get_misses_total'] = $data['get_misses'] - $last['get_misses'];
    $data['get_hits_percentage'] = (($data['get_total'] > 0) ? (($data['get_hits'] - $last['get_hits'])/$data['get_total']) : 0) * 100.0;
    $data['get_misses_percentage'] = (($data['get_total'] > 0) ? (($data['get_misses'] - $last['get_misses'])/$data['get_total']) : 0) * 100.0;
    $data['reads_total'] = $data['bytes_read'] - $last['bytes_read'];
    $data['writes_total'] = $data['bytes_written'] - $last['bytes_written'];

    $output = sprintf(
      "%8s  %4d  % 5s  % 5s  % 5s  % 5s  % 6.2f  % 6.2f  % 5s  % 5s" . PHP_EOL,
      $data['time_string'],
      $data['curr_connections'],
      hr_binary($data['bytes']),
      hr_metric($data['get_total']),
      hr_metric($data['get_hits_total']),
      hr_metric($data['get_misses_total']),
      $data['get_hits_percentage'],
      $data['get_misses_percentage'],
      hr_binary($data['reads_total']),
      hr_binary($data['writes_total'])
    );

    if (!is_array($this->starting_data)) {
      $header = sprintf("Memcache version %s" . PHP_EOL, $start['version']);
      $header .= sprintf("Max Memory Size: %s  Pointer size: %d bit" . PHP_EOL . PHP_EOL, hr_binary($start['limit_maxbytes']), $start['pointer_size']);
      $output = $header . $this->output_header() . $output . PHP_EOL;
      unset($start['version']);
      unset($start['limit_maxbytes']);
      unset($start['pointer_size']);
      unset($start['time']);
      unset($start['pid']);
      $this->starting_data = $start;
    }

    print $output;

    $this->last_data = $data;
  }

  function output_stats_session() {
    $output = PHP_EOL . "Session Statistics:" . PHP_EOL;
    $output .= sprintf("%22s  % 15s  % 15s" . PHP_EOL,
      "Statistic", "Total", "Session"
    );
    $last = $this->last_data;
    $start = $this->starting_data;

    foreach($start as $key => $value) {
      $t_val = $value;
      $s_val = $last[$key] - $start[$key];
      switch ($key) {
      case 'uptime':
         $t_val = hr_time($t_val);
         $s_val = hr_time($s_val);
         break;
      case 'bytes':
      case 'bytes_read':
      case 'bytes_written':
         $t_val = hr_binary($t_val);
         $s_val = hr_binary($s_val);
         break;
      case 'rusage_user':
      case 'rusage_system':
         $t_val = hr_time(sprintf("%10.2f", $t_val));
         $s_val = hr_time(sprintf("%10.2f", $s_val));
      default:
         $t_val = hr_metric($t_val);
         $s_val = hr_metric($s_val);
         break;
      }

      $output .= sprintf("%22s  % 15s  % 15s" . PHP_EOL, $key, $t_val, $s_val);
    }

    return $output;
  }
}

function mcstat_main($argv, $argc) {

  $command = basename($argv[0]);
  $hostname = ($argc >= 2) ? ($argv[1]) : DEFAULT_HOSTNAME;
  $port = ($argc >= 3) ? ($argv[2]) : DEFAULT_PORT;
  $interval = DEFAULT_INTERVAL;

  $srv = new mcstat_server();
  if (!($err = $srv->connect($hostname, $port))) {
    pcntl_signal(SIGTERM, array($srv, 'abort'));
    pcntl_signal(SIGINT, array($srv, 'abort'));
    while (1) {
      $srv->output_stats_update();
      sleep($interval);
    }
  }
  else {
    fprintf(STDERR, "%s: Connection to memcache daemon failed. Error %d: %s\n", $command, $err['errno'], $err['errstr']);
    return $err['errno'];
  }

  $srv->disconnect();
  return 0;
}

